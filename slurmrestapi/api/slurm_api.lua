--[[
  Slurm REST API

  API to access and control Slurm

  The version of the OpenAPI document: Slurm-24.05.5&openapi/dbv0.0.39&openapi/slurmctld&openapi/slurmdbd&openapi/v0.0.39
  Contact: sales@schedmd.com
  Generated by: https://openapi-generator.tech
]]

--package slurmrestapi

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local slurmrestapi_dbv0_0_39_config_info = require "slurmrestapi.model.dbv0_0_39_config_info"
local slurmrestapi_dbv0_0_39_diag = require "slurmrestapi.model.dbv0_0_39_diag"
local slurmrestapi_dbv0_0_39_job_info = require "slurmrestapi.model.dbv0_0_39_job_info"
local slurmrestapi_dbv0_0_39_qos_info = require "slurmrestapi.model.dbv0_0_39_qos_info"
local slurmrestapi_dbv0_0_39_response_associations_delete = require "slurmrestapi.model.dbv0_0_39_response_associations_delete"
local slurmrestapi_dbv0_0_39_tres_info = require "slurmrestapi.model.dbv0_0_39_tres_info"
local slurmrestapi_dbv0_0_39_user_info = require "slurmrestapi.model.dbv0_0_39_user_info"
local slurmrestapi_dbv0_0_39_account_info = require "slurmrestapi.model.dbv0_0_39_account_info"
local slurmrestapi_dbv0_0_39_associations_info = require "slurmrestapi.model.dbv0_0_39_associations_info"
local slurmrestapi_dbv0_0_39_clusters_info = require "slurmrestapi.model.dbv0_0_39_clusters_info"
local slurmrestapi_dbv0_0_39_set_config = require "slurmrestapi.model.dbv0_0_39_set_config"
local slurmrestapi_dbv0_0_39_tres_update = require "slurmrestapi.model.dbv0_0_39_tres_update"
local slurmrestapi_dbv0_0_39_update_qos = require "slurmrestapi.model.dbv0_0_39_update_qos"
local slurmrestapi_dbv0_0_39_update_users = require "slurmrestapi.model.dbv0_0_39_update_users"
local slurmrestapi_dbv0_0_39_wckey_info = require "slurmrestapi.model.dbv0_0_39_wckey_info"
local slurmrestapi_status = require "slurmrestapi.model.status"
local slurmrestapi_v0_0_39_diag = require "slurmrestapi.model.v0_0_39_diag"
local slurmrestapi_v0_0_39_job_submission_response = require "slurmrestapi.model.v0_0_39_job_submission_response"
local slurmrestapi_v0_0_39_job_update_response = require "slurmrestapi.model.v0_0_39_job_update_response"
local slurmrestapi_v0_0_39_jobs_response = require "slurmrestapi.model.v0_0_39_jobs_response"
local slurmrestapi_v0_0_39_licenses_info = require "slurmrestapi.model.v0_0_39_licenses_info"
local slurmrestapi_v0_0_39_nodes_response = require "slurmrestapi.model.v0_0_39_nodes_response"
local slurmrestapi_v0_0_39_partitions_response = require "slurmrestapi.model.v0_0_39_partitions_response"
local slurmrestapi_v0_0_39_pings = require "slurmrestapi.model.v0_0_39_pings"
local slurmrestapi_v0_0_39_reservations_response = require "slurmrestapi.model.v0_0_39_reservations_response"
local slurmrestapi_v0_0_40_openapi_diag_resp = require "slurmrestapi.model.v0_0_40_openapi_diag_resp"
local slurmrestapi_v0_0_40_openapi_job_info_resp = require "slurmrestapi.model.v0_0_40_openapi_job_info_resp"
local slurmrestapi_v0_0_40_openapi_job_post_response = require "slurmrestapi.model.v0_0_40_openapi_job_post_response"
local slurmrestapi_v0_0_40_openapi_job_submit_response = require "slurmrestapi.model.v0_0_40_openapi_job_submit_response"
local slurmrestapi_v0_0_40_openapi_kill_jobs_resp = require "slurmrestapi.model.v0_0_40_openapi_kill_jobs_resp"
local slurmrestapi_v0_0_40_openapi_licenses_resp = require "slurmrestapi.model.v0_0_40_openapi_licenses_resp"
local slurmrestapi_v0_0_40_openapi_nodes_resp = require "slurmrestapi.model.v0_0_40_openapi_nodes_resp"
local slurmrestapi_v0_0_40_openapi_partition_resp = require "slurmrestapi.model.v0_0_40_openapi_partition_resp"
local slurmrestapi_v0_0_40_openapi_ping_array_resp = require "slurmrestapi.model.v0_0_40_openapi_ping_array_resp"
local slurmrestapi_v0_0_40_openapi_reservation_resp = require "slurmrestapi.model.v0_0_40_openapi_reservation_resp"
local slurmrestapi_v0_0_40_openapi_resp = require "slurmrestapi.model.v0_0_40_openapi_resp"
local slurmrestapi_v0_0_40_openapi_shares_resp = require "slurmrestapi.model.v0_0_40_openapi_shares_resp"
local slurmrestapi_v0_0_41_openapi_diag_resp = require "slurmrestapi.model.v0_0_41_openapi_diag_resp"
local slurmrestapi_v0_0_41_openapi_job_alloc_resp = require "slurmrestapi.model.v0_0_41_openapi_job_alloc_resp"
local slurmrestapi_v0_0_41_openapi_job_info_resp = require "slurmrestapi.model.v0_0_41_openapi_job_info_resp"
local slurmrestapi_v0_0_41_openapi_job_post_response = require "slurmrestapi.model.v0_0_41_openapi_job_post_response"
local slurmrestapi_v0_0_41_openapi_job_submit_response = require "slurmrestapi.model.v0_0_41_openapi_job_submit_response"
local slurmrestapi_v0_0_41_openapi_kill_jobs_resp = require "slurmrestapi.model.v0_0_41_openapi_kill_jobs_resp"
local slurmrestapi_v0_0_41_openapi_licenses_resp = require "slurmrestapi.model.v0_0_41_openapi_licenses_resp"
local slurmrestapi_v0_0_41_openapi_nodes_resp = require "slurmrestapi.model.v0_0_41_openapi_nodes_resp"
local slurmrestapi_v0_0_41_openapi_partition_resp = require "slurmrestapi.model.v0_0_41_openapi_partition_resp"
local slurmrestapi_v0_0_41_openapi_ping_array_resp = require "slurmrestapi.model.v0_0_41_openapi_ping_array_resp"
local slurmrestapi_v0_0_41_openapi_reservation_resp = require "slurmrestapi.model.v0_0_41_openapi_reservation_resp"
local slurmrestapi_v0_0_41_openapi_resp = require "slurmrestapi.model.v0_0_41_openapi_resp"
local slurmrestapi_v0_0_41_openapi_shares_resp = require "slurmrestapi.model.v0_0_41_openapi_shares_resp"
local slurmrestapi_v0_0_39_job_desc_msg = require "slurmrestapi.model.v0_0_39_job_desc_msg"
local slurmrestapi_v0_0_39_job_submission = require "slurmrestapi.model.v0_0_39_job_submission"
local slurmrestapi_v0_0_39_update_node_msg = require "slurmrestapi.model.v0_0_39_update_node_msg"
local slurmrestapi_v0_0_40_job_desc_msg = require "slurmrestapi.model.v0_0_40_job_desc_msg"
local slurmrestapi_v0_0_40_job_submit_req = require "slurmrestapi.model.v0_0_40_job_submit_req"
local slurmrestapi_v0_0_40_kill_jobs_msg = require "slurmrestapi.model.v0_0_40_kill_jobs_msg"
local slurmrestapi_v0_0_40_update_node_msg = require "slurmrestapi.model.v0_0_40_update_node_msg"
local slurmrestapi_v0_0_41_job_alloc_req = require "slurmrestapi.model.v0_0_41_job_alloc_req"
local slurmrestapi_v0_0_41_job_desc_msg = require "slurmrestapi.model.v0_0_41_job_desc_msg"
local slurmrestapi_v0_0_41_job_submit_req = require "slurmrestapi.model.v0_0_41_job_submit_req"
local slurmrestapi_v0_0_41_kill_jobs_msg = require "slurmrestapi.model.v0_0_41_kill_jobs_msg"
local slurmrestapi_v0_0_41_update_node_msg = require "slurmrestapi.model.v0_0_41_update_node_msg"

local slurm_api = {}
local slurm_api_mt = {
	__name = "slurm_api";
	__index = slurm_api;
}

local function new_slurm_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "http://localhost";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, slurm_api_mt)
end

function slurm_api:slurm_v0039_cancel_job(job_id, signal)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/job/%s?signal=%s",
			self.basePath, job_id, http_util.encodeURIComponent(signal));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_delete_node(node_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_diag()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/diag",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_diag.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_job(job_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/job/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_jobs_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_jobs(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/jobs?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_jobs_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_node(node_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_nodes_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_nodes(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/nodes?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_nodes_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_partition(partition_name, update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/partition/%s?update_time=%s",
			self.basePath, partition_name, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_partitions_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_partitions(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/partitions?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_partitions_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_reservation(reservation_name, update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/reservation/%s?update_time=%s",
			self.basePath, reservation_name, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_reservations_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_get_reservations(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/reservations?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_reservations_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_ping()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/ping",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_pings.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_slurmctld_get_licenses()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/licenses",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_licenses_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_submit_job(v0_0_39_job_submission)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/job/submit",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_39_job_submission))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_job_submission_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_update_job(job_id, v0_0_39_job_desc_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/job/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_39_job_desc_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_39_job_update_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0039_update_node(node_name, v0_0_39_update_node_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.39/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_39_update_node_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_delete_job(job_id, signal, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/job/%s?signal=%s&flags=%s",
			self.basePath, job_id, http_util.encodeURIComponent(signal), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_delete_jobs(v0_0_40_kill_jobs_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/jobs",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_40_kill_jobs_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_kill_jobs_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_delete_node(node_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_diag()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/diag",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_diag_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_job(job_id, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/job/%s?update_time=%s&flags=%s",
			self.basePath, job_id, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_jobs(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/jobs?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_jobs_state(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/jobs/state?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_licenses()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/licenses",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_licenses_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_node(node_name, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/node/%s?update_time=%s&flags=%s",
			self.basePath, node_name, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_nodes_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_nodes(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/nodes?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_nodes_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_partition(partition_name, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/partition/%s?update_time=%s&flags=%s",
			self.basePath, partition_name, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_partition_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_partitions(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/partitions?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_partition_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_ping()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/ping",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_ping_array_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_reconfigure()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/reconfigure",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_reservation(reservation_name, update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/reservation/%s?update_time=%s",
			self.basePath, reservation_name, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_reservation_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_reservations(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/reservations?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_reservation_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_get_shares(accounts, users)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/shares?accounts=%s&users=%s",
			self.basePath, http_util.encodeURIComponent(accounts), http_util.encodeURIComponent(users));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_shares_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_post_job(job_id, v0_0_40_job_desc_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/job/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_40_job_desc_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_job_post_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_post_job_submit(v0_0_40_job_submit_req)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/job/submit",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_40_job_submit_req))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_job_submit_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0040_post_node(node_name, v0_0_40_update_node_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.40/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_40_update_node_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_40_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_delete_job(job_id, signal, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/job/%s?signal=%s&flags=%s",
			self.basePath, job_id, http_util.encodeURIComponent(signal), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_delete_jobs(v0_0_41_kill_jobs_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/jobs",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_41_kill_jobs_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_kill_jobs_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_delete_node(node_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_diag()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/diag",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_diag_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_job(job_id, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/job/%s?update_time=%s&flags=%s",
			self.basePath, job_id, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_jobs(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/jobs?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_jobs_state(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/jobs/state?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_info_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_licenses()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/licenses",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_licenses_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_node(node_name, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/node/%s?update_time=%s&flags=%s",
			self.basePath, node_name, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_nodes_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_nodes(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/nodes?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_nodes_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_partition(partition_name, update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/partition/%s?update_time=%s&flags=%s",
			self.basePath, partition_name, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_partition_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_partitions(update_time, flags)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/partitions?update_time=%s&flags=%s",
			self.basePath, http_util.encodeURIComponent(update_time), http_util.encodeURIComponent(flags));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_partition_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_ping()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/ping",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_ping_array_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_reconfigure()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/reconfigure",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_reservation(reservation_name, update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/reservation/%s?update_time=%s",
			self.basePath, reservation_name, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_reservation_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_reservations(update_time)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/reservations?update_time=%s",
			self.basePath, http_util.encodeURIComponent(update_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_reservation_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_get_shares(accounts, users)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/shares?accounts=%s&users=%s",
			self.basePath, http_util.encodeURIComponent(accounts), http_util.encodeURIComponent(users));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_shares_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_post_job(job_id, v0_0_41_job_desc_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/job/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_41_job_desc_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_post_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_post_job_allocate(v0_0_41_job_alloc_req)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/job/allocate",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_41_job_alloc_req))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_alloc_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_post_job_submit(v0_0_41_job_submit_req)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/job/submit",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_41_job_submit_req))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_job_submit_response.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurm_v0041_post_node(node_name, v0_0_41_update_node_msg)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurm/v0.0.41/node/%s",
			self.basePath, node_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(v0_0_41_update_node_msg))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_v0_0_41_openapi_resp.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_add_clusters(dbv0_0_39_clusters_info)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/clusters",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_clusters_info))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_add_wckeys(dbv0_0_39_wckey_info)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/wckeys",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_wckey_info))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_account(account_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/account/%s",
			self.basePath, account_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_association(cluster, account, user, partition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/association?cluster=%s&account=%s&user=%s&partition=%s",
			self.basePath, http_util.encodeURIComponent(cluster), http_util.encodeURIComponent(account), http_util.encodeURIComponent(user), http_util.encodeURIComponent(partition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_response_associations_delete.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_associations(cluster, account, user, partition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/associations?cluster=%s&account=%s&user=%s&partition=%s",
			self.basePath, http_util.encodeURIComponent(cluster), http_util.encodeURIComponent(account), http_util.encodeURIComponent(user), http_util.encodeURIComponent(partition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_response_associations_delete.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_cluster(cluster_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/cluster/%s",
			self.basePath, cluster_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_qos(qos_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/qos/%s",
			self.basePath, qos_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_user(user_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/user/%s",
			self.basePath, user_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_delete_wckey(wckey)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/wckey/%s",
			self.basePath, wckey);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_diag()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/diag",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_diag.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_account(account_name, with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/account/%s?with_deleted=%s",
			self.basePath, account_name, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_account_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_accounts(with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/accounts?with_deleted=%s",
			self.basePath, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_account_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_association(cluster, account, user, partition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/association?cluster=%s&account=%s&user=%s&partition=%s",
			self.basePath, http_util.encodeURIComponent(cluster), http_util.encodeURIComponent(account), http_util.encodeURIComponent(user), http_util.encodeURIComponent(partition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_associations_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_associations(cluster, account, user, partition)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/associations?cluster=%s&account=%s&user=%s&partition=%s",
			self.basePath, http_util.encodeURIComponent(cluster), http_util.encodeURIComponent(account), http_util.encodeURIComponent(user), http_util.encodeURIComponent(partition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_associations_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_cluster(cluster_name)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/cluster/%s",
			self.basePath, cluster_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_clusters_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_clusters()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/clusters",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_clusters_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_config()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/config",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_config_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_job(job_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/job/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_jobs(users, submit_time, start_time, end_time, account, association, cluster, constraints, cpus_max, cpus_min, skip_steps, disable_wait_for_result, exit_code, format, group, job_name, nodes_max, nodes_min, partition, qos, reason, reservation, state, step, node, wckey)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/jobs?users=%s&submit_time=%s&start_time=%s&end_time=%s&account=%s&association=%s&cluster=%s&constraints=%s&cpus_max=%s&cpus_min=%s&skip_steps=%s&disable_wait_for_result=%s&exit_code=%s&format=%s&group=%s&job_name=%s&nodes_max=%s&nodes_min=%s&partition=%s&qos=%s&reason=%s&reservation=%s&state=%s&step=%s&node=%s&wckey=%s",
			self.basePath, http_util.encodeURIComponent(users), http_util.encodeURIComponent(submit_time), http_util.encodeURIComponent(start_time), http_util.encodeURIComponent(end_time), http_util.encodeURIComponent(account), http_util.encodeURIComponent(association), http_util.encodeURIComponent(cluster), http_util.encodeURIComponent(constraints), http_util.encodeURIComponent(cpus_max), http_util.encodeURIComponent(cpus_min), http_util.encodeURIComponent(skip_steps), http_util.encodeURIComponent(disable_wait_for_result), http_util.encodeURIComponent(exit_code), http_util.encodeURIComponent(format), http_util.encodeURIComponent(group), http_util.encodeURIComponent(job_name), http_util.encodeURIComponent(nodes_max), http_util.encodeURIComponent(nodes_min), http_util.encodeURIComponent(partition), http_util.encodeURIComponent(qos), http_util.encodeURIComponent(reason), http_util.encodeURIComponent(reservation), http_util.encodeURIComponent(state), http_util.encodeURIComponent(step), http_util.encodeURIComponent(node), http_util.encodeURIComponent(wckey));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_job_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_qos(with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/qos?with_deleted=%s",
			self.basePath, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_qos_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_single_qos(qos_name, with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/qos/%s?with_deleted=%s",
			self.basePath, qos_name, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_qos_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_tres()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/tres",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_tres_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_user(user_name, with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/user/%s?with_deleted=%s",
			self.basePath, user_name, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_user_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_users(with_deleted)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/users?with_deleted=%s",
			self.basePath, http_util.encodeURIComponent(with_deleted));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_user_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_wckey(wckey)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/wckey/%s",
			self.basePath, wckey);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_wckey_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_get_wckeys()
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/wckeys",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_dbv0_0_39_wckey_info.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_set_config(dbv0_0_39_set_config)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/config",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_set_config))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_update_accounts(dbv0_0_39_account_info)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/accounts",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_account_info))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_update_associations(dbv0_0_39_associations_info)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/associations",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_associations_info))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_update_qos(dbv0_0_39_update_qos)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/qos",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_update_qos))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_update_tres(dbv0_0_39_tres_update)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/tres",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_tres_update))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function slurm_api:slurmdb_v0039_update_users(dbv0_0_39_update_users)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/slurmdb/v0.0.39/users",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json", "application/x-yaml" }
	req.headers:upsert("accept", "application/json")

	-- TODO: create a function to select proper content-type
	--local var_accept = { "application/json", "application/x-yaml" }
	req.headers:upsert("content-type", "application/json")

	req:set_body(dkjson.encode(dbv0_0_39_update_users))

	-- api key in headers 'X-SLURM-USER-NAME'
	if self.api_key['X-SLURM-USER-NAME'] then
		req.headers:upsert("user", self.api_key['X-SLURM-USER-NAME'])
	end
	-- api key in headers 'X-SLURM-USER-TOKEN'
	if self.api_key['X-SLURM-USER-TOKEN'] then
		req.headers:upsert("token", self.api_key['X-SLURM-USER-TOKEN'])
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		local body, err, errno2 = stream:get_body_as_string()
		-- exception when getting the HTTP body
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		local result, _, err3 = dkjson.decode(body)
		-- exception when decoding the HTTP body
		if result == nil then
			return nil, err3
		end
		return slurmrestapi_status.cast(result), headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_slurm_api;
}
